"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var yup = _interopRequireWildcard(require("yup"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Rules = /*#__PURE__*/function () {
  function Rules(rules) {
    this.rules = [].concat(rules);
  }

  var _proto = Rules.prototype;

  _proto.isRule = function isRule(arg) {
    if (Array.isArray(arg) && Array.isArray(arg[0]) && yup[arg[0][0]]) {
      return true;
    }

    return false;
  };

  _proto.handleObject = function handleObject(obj) {
    var handledObj = {};

    for (var key in obj) {
      handledObj[key] = obj.hasOwnProperty(key) && this.isRule(obj[key]) ? new Rules(obj[key]).toYup() : obj[key];
    }

    return handledObj;
  };

  _proto.processArgs = function processArgs(args) {
    var _this = this;

    return args.reduce(function (result, arg) {
      // test for arg !== null, because typeof null === "object", but null.constructor is Uncaught TypeError
      if (arg !== null && typeof arg === 'object' && arg.constructor === Object && !Array.isArray(arg)) {
        return [].concat(result, [_this.handleObject(arg)]);
      } else if (_this.isRule(arg)) {
        return [].concat(result, [new Rules(arg).toYup()]);
      }

      return [].concat(result, [arg]);
    }, []);
  };

  _proto.toYup = function toYup() {
    var _this2 = this;

    var _this$rules = this.rules,
        _this$rules$ = _this$rules[0],
        type = _this$rules$[0],
        typeArgs = _this$rules$.slice(1),
        rules = _this$rules.slice(1);

    if (!type || !yup[type]) {
      throw new Error('Type ' + type + ' does not exist');
    }

    var ruleTypeArgs = this.processArgs(typeArgs);
    var yupRule = yup[type].apply(yup, ruleTypeArgs);
    rules.forEach(function (_ref) {
      var _yupRule;

      var fn = _ref[0],
          rule = _ref.slice(1);

      if (!fn || !yupRule[fn]) {
        throw new Error('Method ' + fn + ' does not exist');
      }

      var args = _this2.processArgs(rule);

      yupRule = (_yupRule = yupRule)[fn].apply(_yupRule, args);
    });
    return yupRule;
  };

  return Rules;
}();

exports["default"] = Rules;
module.exports = exports.default;